== How It Works

This section explains the architecture of the plugin and how it handles different types of requests.

=== Architecture Overview

The plugin consists of three main components that work together:

1. **ServerTimingFilter** - A servlet filter that wraps all HTTP responses
2. **ServerTimingInterceptor** - A Grails interceptor that tracks controller action and view timing
3. **ServerTimingResponseWrapper** - A response wrapper that ensures headers are added before the response is committed

=== Request Flow

==== Controller Requests

When a request hits a Grails controller action, the following sequence occurs:

[source,text]
----
1. ServerTimingFilter receives request
   - Creates TimingMetric object
   - Starts 'total' timer
   - Starts 'other' timer
   - Wraps response with ServerTimingResponseWrapper

2. ServerTimingInterceptor.before() is called
   - Starts 'action' timer

3. Controller action executes
   - Your business logic runs here

4. ServerTimingInterceptor.after() is called
   - Stops 'action' timer
   - Starts 'view' timer

5. View/GSP renders

6. Response is committed
   - ServerTimingResponseWrapper intercepts the commit
   - Removes 'other' timer if an action/view was invoked, otherwise stops it
   - Stops 'action' timer if still running (edge case: action committed the response directly)
   - Stops 'view' timer if still running
   - Stops 'total' timer
   - Adds Server Timing header to response
----

==== Static Resources and Other Requests

For requests that do not hit a Grails controller (static assets, images, CSS, JavaScript, etc.):

[source,text]
----
1. ServerTimingFilter receives request
   - Creates TimingMetric object
   - Starts 'total' timer
   - Starts 'other' timer
   - Wraps response with ServerTimingResponseWrapper

2. ServerTimingInterceptor is NOT called
   - 'action' and 'view' timers are never created

3. Asset pipeline or other handler processes request

4. Response is committed
   - ServerTimingResponseWrapper intercepts the commit
   - Stops 'other' timer
   - Stops 'total' timer
   - Adds Server Timing header to response
----

=== The Response Wrapper

A key technical challenge with Server Timing is that HTTP headers must be sent *before* the response body.
However, we do not know the final timing values until *after* the view has rendered.

The `ServerTimingResponseWrapper` solves this by wrapping the original `HttpServletResponse` and deferring the
`Server-Timing` header injection until the last possible moment -- just before the first byte of body content is
written. This maximizes timing accuracy because all metrics (action, view, etc.) have as much time as possible to
accumulate before the header value is computed and frozen.

==== Deferred Header Injection

Both output paths use the same deferred strategy:

* **`getOutputStream()`** returns a `ServerTimingServletOutputStream` that intercepts `write()`, `flush()`, and
`close()`. On the first call, it triggers header injection before delegating to the underlying stream.
* **`getWriter()`** returns a `ServerTimingPrintWriter` that intercepts `write()`, `flush()`, and `close()` in the
same way. All higher-level `PrintWriter` methods (`print()`, `println()`, `printf()`, etc.) route through the
overridden `write()` methods, so they are also covered.

In both cases, subsequent writes pass through directly without any overhead.

==== Other Commit Points

The wrapper also intercepts methods that commit the response without writing body content:

* `sendError()` -- error responses
* `sendRedirect()` -- redirect responses
* `flushBuffer()` -- explicit buffer flushes

These inject the header eagerly since the response is being committed immediately.

==== Safety Net

As a final safeguard, the `ServerTimingFilter` calls `beforeCommit()` in a `finally` block after the filter chain
completes. This handles edge cases where no output was written (e.g., 204 No Content responses). The header
injection is idempotent -- a boolean flag ensures it only runs once regardless of how many commit points are hit.

=== Metric Descriptions

Each metric in the `Server-Timing` header includes:

* **name** - A short identifier (e.g., `action`, `view`, `total`)
* **dur** - Duration in milliseconds
* **desc** - A human-readable description

NOTE: This plugin only includes metrics that have been started and stopped (i.e., have a duration).
Metrics that were created but never started, or started but never stopped, are not included in the header.

Example:

[source,http]
----
Server-Timing: action;dur=45.2;desc="Action",view;dur=98.7;desc="View"
----

=== Controller vs Non-Controller Requests

The plugin handles different request types automatically:

|===
| Request Type | Metrics Captured | Example

| Controller with view
| `total`, `action`, `view`
| `/book/show/1`

| Controller with render
| `total`, `action`
| `/api/books` (JSON response)

| Static assets
| `total`, `other`
| `/assets/application.css`

| Other resources
| `total`, `other`
| `/favicon.ico`
|===



